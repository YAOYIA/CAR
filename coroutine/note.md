# 结构
# 主要的类
## thread 
主要是为了完成
semaphore
conditon_varible是c++一种线程间的同步机制，主要用于在多线程的环境下实现条件等待和通知，从而协调线程之间的执行顺序。通常用于需要等待某个条件成立后才可以继续执行的场景。
一般需要配合互斥锁std::unique_lock 一起使用

## fiber
负责协程的创建、暂停等真正运行任务的地方

## scheduler
没有这个类就需要用户自己去调度协程的执行于暂停，显得不够灵活、不够智能。

## ioscheduler::io+scheduler
此类使用epoll监听fd上绑定的读写事件，当读写事件触发将其放入到调度器中等待调度

## timer
服务器也需要定时器，不然遇到定时任务该如何执行。所有此类完成定时器的创建、删除和取消，使用最小堆的结果，将超时定时器触发作为固定信号tickle来触发ioschedule等待的epoll wait

## hook
hook + ioscheduler 才可以体现出这是一个非阻塞的服务器框架，虽然前面实现了协程调度，但是在每个系统调用中，不会改变函数内部结构无法做出协程的挂起和恢复，也就是sleep(1)该睡多久还是多久，无法体现我们使用协程的优势，所以就将使用hook改变原函数增添内容，更好搭配上我们的ioschedule，将其sleep(1)作为定时任务，放入到time中的定时器堆中等待超时触发，后唤醒epoll去放入到调度器中执行。

## 几个模块之间的协作
fiber：是任务执行的单元，所有的任务代码运行在其中
scheduler：管理fiber的执行顺序，实现协程的挂起和恢复
ioscheduler：扩展了scheduler的功能，实现了IO事件触发调度
timer：为scheduler和ioscheduler提供定时任务支持
hook：改变系统的调用行为，使其更好于协程的框架配合。

# 信号量
信号量的本质是 计数器+等待队列，用来控制对共享资源的访问
P 操作（wait/down）：申请资源，计数器减 1；若计数器≤0，则阻塞等待，直到有其他线程释放资源。
V 操作（signal/up）：释放资源，计数器加 1；若有线程阻塞等待，则唤醒其中一个。


# 协程
协程有两个关键词 resume（恢复）和yeild（暂停）
协程是一种轻量级的线程，用户线程
协程是一种执行过程中可以yeild和resume的子程序。




