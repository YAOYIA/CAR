# 智能指针
理解智能指针的循环引用：首先要明确其设计的目标--通过引用计数(shared_ptr)或者独占所有权(unique_ptr,weak_ptr)，自动管理内存，避免内存泄漏。而循环引用是shared_ptr
(基于引用计数)特有的风险，本质是两个或者多个对象通过shared_ptr互相指向，导致他们的引用的计数永远无法减至0，最终内存无法释放。
首先要明确的一点是只有share_ptr存在循环引用问题
unique_ptr:独占所有权，同一时间只有一个unique_ptr指向对象，无法拷贝，不存在多个指针互相指向的情景，因此不会存在循环引用
weak_ptr:弱引用，不参与引用计数的计算，仅作为“观察者”指向shared_ptr管理的对象，本身无法直接访问对象（需要先通过lock()转为shared_ptr），因此不会发生循环引用。
shared_ptr:共享所有权，多个shared_ptr可以指向同一个对象，内部共同维护一个引用计数。

循环引用的根源，正是 shared_ptr 的 “共享所有权” 和 “引用计数” 机制 —— 当对象间通过 shared_ptr 形成闭环时，它们的引用计数会互相 “卡住”，永远无法归零。

```
#include <iostream>
#include <memory>
#include <mutex>


class Node
{
private:
    /* data */
public:
    int value;
    std::shared_ptr<Node> prev;
    // 将 prev 改为 weak_ptr 的核心是打破了 “双向强引用” 的闭环：
    // next 保留为 shared_ptr，保证 “后继节点” 的生命周期能被当前节点正常持有；
    // prev 改为 weak_ptr，避免对 “前驱节点” 形成强引用，从而让前驱节点的引用计数能正常减至 0 并析构；
    // 简单来说：weak_ptr 既保留了 “指向另一个节点” 的能力，又不会因为这个指向而增加引用计数，从而打破了循环引用的死锁，让对象的引用计数能正常归零并析构。
    // std::weak_ptr<Node> prev;
    std::shared_ptr<Node> next;
    Node(int val):value(val)
    {
        std::cout<<"Node 构造"<<std::endl;
    }
    ~Node()
    {
        std::cout<<"Node 析构"<<std::endl;
    }
};

/*
为什么会这样？我们一步步拆解引用计数的变化过程：
创建节点时：
node1（shared_ptr）指向 Node(1)，Node(1) 的引用计数 = 1；
node2（shared_ptr）指向 Node(2)，Node(2) 的引用计数 = 1。
互相指向时：
node1->next = node2：Node(2) 新增一个 shared_ptr 指向它，引用计数 +1 → 2；
node2->prev = node1：Node(1) 新增一个 shared_ptr 指向它，引用计数 +1 → 2。
函数结束时：
node1 和 node2 是 testCycle 函数的局部变量，出作用域后会被销毁：
node1 销毁 → Node(1) 的引用计数 -1 → 1（此时仍有 node2->prev 指向它）；
node2 销毁 → Node(2) 的引用计数 -1 → 1（此时仍有 node1->next 指向它）。
最终状态：
Node(1) 和 Node(2) 的引用计数都停留在 1，永远无法减至 0；
系统无法判断这两个对象是否还在被使用，因此不会释放它们的内存 —— 这就是循环引用导致的内存泄漏。
*/
void testCycle()
{
    //1.创建两个shared_ptr,分别管理node1和node2
    std::shared_ptr<Node> node1 = std::make_shared<Node>(1);
    std::shared_ptr<Node> node2 = std::make_shared<Node>(2);

    //2.让两个节点互相指向，形成闭环
    node1->next = node2;
    node2->prev = node1;

}

int main()
{
    testCycle();
    std::cout<<"test end"<<std::endl;
    return 0;
}
```

# 为什么使用虚拟头、尾节点？核心目的是简化链表操作的边界判断，避免空指针的问题
没有虚拟节点时的痛点：
插入第一个真实节点时，需要判断 “链表是否为空”（头指针是否为 nullptr）；
删除最后一个真实节点时，需要判断 “是否只剩一个节点”（避免尾指针为空）；
边界操作逻辑复杂，容易出现空指针崩溃。

有虚拟节点后的优势：
插入节点：无论链表是否为空，真实节点都只需插入 dummyHead_->next 和 dummyHead 之间（头部插入），或任意两个节点之间，无需判断边界；
示例：插入节点 node 到头部：node->prev = dummyHead_ → node->next = dummyHead_->next → dummyHead_->next->prev = node → dummyHead_->next = node。
删除节点：无论删除哪个真实节点（包括最后一个），都只需修改该节点前后节点的指针，无需判断 “是否是头 / 尾节点”；
示例：删除节点 node：node->prev->next = node->next → node->next->prev = node->prev。
判空逻辑简化：只需判断 dummyHead_->next == dummyTail_ 即可知道链表是否为空（无真实节点）。